import os
import sys
import logging
import glob
import json
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord

from genofunk import editfile
from genofunk.sequence_utils import *

EditFile = editfile.EditFile
Edit = editfile.Edit

class Apply():
    def __init__(self):
        self.consensus_sequence = None
        self.edits = None
        self.coordinates = None

    def load_coordinates_file(self, coordinates_file, features_list=None):
        """
        Loads coordinates file generated by `annotate` to self.coordinates. If a features_list is provided, only loads
        coordinates that lie within these features
        :param coordinates_file: file of coordinates output by `annotate`
        :param features_list: list of features named in reference JSON to restrict to
        :return:
        """
        assert self.coordinates is not None

        if not os.path.exists(coordinates_file):
            logging.error("Paired coordinates file %s does not exist!" % coordinates_file)
            assert (os.path.exists(coordinates_file))

        if features_list:
            for key in features_list:
                add_key_to_coordinate_dict(self.coordinates, key)

        with open(coordinates_file) as json_file:
            data = json.load(json_file)
            for key in data:
                if features_list and key not in features_list:
                    continue
                add_key_to_coordinate_dict(self.coordinates, key)
                for record_name in data[key]:
                    if record_name in self.coordinates[key]:
                        logging.error(
                            "Record name %s exists in multiple consensus files (and coordinates files). This will "
                            "break things!" % record_name)
                    assert record_name not in self.coordinates[key]
                self.coordinates[key].update(data[key])

    def load_consensus_file(self, consensus_file, filetype="fasta"):
        """
        Loads a consensus file for a sample, checking for non-unique record ids with existing consensus records
        :param consensus_file: FASTA file for a sample
        :param filetype: (Default: FASTA)
        :return:
        """

        assert self.consensus_sequence is not None

        if not os.path.exists(consensus_file):
            logging.error("Paired consensus file %s does not exist!" % consensus_file)
            assert (os.path.exists(consensus_file))

        record_dict = SeqIO.index(consensus_file, filetype)
        assert len(record_dict) > 0
        for key in record_dict:
            if key in self.consensus_sequence:
                logging.error(
                    "Record name %s exists in multiple consensus files. This will "
                    "break things!" % key)
            assert key not in self.consensus_sequence
        self.consensus_sequence.update(record_dict)
        record_dict.close()
        logging.debug("After loading consensus file %s, we have %d consensus records " % (consensus_file,
                                                                                          len(self.consensus_sequence)))

    def load_edits_in_range(self, edit_file, features_list=None):
        """
        Loads list of edits from an editfile and appends them to self.edits. If a features_list is provided, only loads
        edits that lie within the coordinate range for those features. Sorts edits in reverse order by sequence position
        :param edit_file:
        :param features_list: list of features named in reference JSON to restrict to
        :return:
        """
        assert self.coordinates is not None

        if not features_list:
            self.edits = EditFile(edit_file)
        else:
            self.edits = EditFile()
            new_edits = EditFile(edit_file)
            for edit in new_edits.edits:
                for feature in self.coordinates:
                    if edit.sequence_id in self.coordinates[feature] and \
                            self.coordinates[feature][edit.sequence_id]["start"] <= edit.sequence_position <= \
                            self.coordinates[feature][edit.sequence_id]["end"]:
                        self.edits.add_edit(edit)

        self.edits.sort(reverse=True, seq_position=True)
        logging.debug("Now have %d sorted edits" % len(self.edits.edits))

    def load_input_files(self, directory, edit_filepath, features_list=None, filetype="fasta"):
        """
        Looks for pairs of *.fasta, *.fasta.edit, *.fasta.coordinates files in a directory, and loads them into single
        big lists of consensus_sequences and coordinates and edits
        :param directory:
        :param filetype: if consensus sequence file not FASTA
        :return:
        """
        self.coordinates = {}
        self.consensus_sequence = {}

        edit_files = glob.glob("%s/*.edits" %directory)
        edit_files = list(filter(lambda x: not x.endswith(edit_filepath), edit_files))

        if len(edit_files) == 0:
            logging.error("No edit files found in directory %s" %directory)
            assert(len(edit_files) > 0)

        for edit_file in edit_files:
            coordinates_file = edit_file.replace(".edits", ".coordinates")
            self.load_coordinates_file(coordinates_file, features_list=features_list)
            consensus_file = edit_file.replace(".edits","")
            self.load_consensus_file(consensus_file, filetype)

        self.load_edits_in_range(edit_filepath, features_list=features_list)

    def apply_loaded_edits(self, filter_by_accepted=True):
        """
        Apply the edits to the consensus nucleotide sequences in place (assumes reverse order to avoid offset errors)
        :return:
        """
        if not self.edits or len(self.edits.edits) == 0:
            return
        for edit in self.edits.edits:
            record = self.consensus_sequence[edit.sequence_id]
            edit.apply_edit(record, filter_by_accepted=filter_by_accepted)

    def save_updated_consensuses(self, filepath=None, features=None, concat=False, amino_acid=False):
        """
        Save new consensus sequences with edits applied to file, restricting to a feature or translating as required
        :param filepath: output file name (Default : stdout)
        :param feature: an optional named feature to restrict to (Default:None)
        :param amino_acid: translate to amino acid sequence (Default:False)
        :return:
        """
        if filepath:
            out_handle = open(filepath, 'w')
        else:
            out_handle = sys.stdout
            if features:
                out_handle.write(features)

        for seq_name in self.consensus_sequence:
            seq = self.consensus_sequence[seq_name]
            assert type(seq.seq), Seq

            if features:
                out_seq = Seq("")
                for feature in features:
                    if seq_name not in self.coordinates[feature]:
                        continue
                    coordinates = get_coordinates_from_json(self.coordinates[feature][seq_name], pairs=False)
                    feature_seq, coordinates = get_sequence(seq.seq, coordinates=coordinates, amino_acid=amino_acid, stop_symbol='X')
                    out_seq = out_seq + feature_seq
                out_seq = SeqRecord(out_seq, id=seq.id, name=seq.name, description=seq.description)
            else:
                out_seq, coordinates = get_sequence(seq.seq, amino_acid=amino_acid, stop_symbol='X')
                out_seq = SeqRecord(seq=Seq(out_seq), id=seq.id, name=seq.name, description=seq.description)
            if amino_acid and not is_open_reading_frame(out_seq):
                logging.debug("After finding edits, still have bad open reading frame for query sequence %s with "
                              "coordinates %s" % (seq, str_coordinates(coordinates)))
            SeqIO.write(out_seq, out_handle, "fasta")

        if filepath:
            out_handle.close()

    def run(self, directory, edit_filepath, output_prefix, features="", concat=False):
        """
        Applies accepted edits from a list to consensus sequences and outputs both nucleotide and amino acid FASTA files
        for alignment. If a list of features is provided, outputs a file pair per feature.
        :param directory: directory containing *.fasta, *.fasta.edits, *.fasta.coordinates pairs
        :param edit_filepath: file containing merged edits
        :param output_prefix: prefix for output file names
        :param features: comma separated list of reference features to restrict to
        :return:
        """
        if features:
            features_list = features.split(",")
        else:
            features_list = None
        self.load_input_files(directory, edit_filepath, features_list=features_list)
        if concat and features_list is None:
            features_list = self.coordinates.keys()
        self.apply_loaded_edits()

        if features_list and not concat:
            for feature in features_list:
                self.save_updated_consensuses("%s.%s.na.fasta" % (output_prefix, feature), features=[feature])
                self.save_updated_consensuses("%s.%s.aa.fasta" % (output_prefix, feature), features=[feature],
                                              amino_acid=True)
        else:
            self.save_updated_consensuses("%s.na.fasta" % output_prefix, features=features_list, concat=concat)
            self.save_updated_consensuses("%s.aa.fasta" % output_prefix, features=features_list, concat=concat,
                                          amino_acid=True)
